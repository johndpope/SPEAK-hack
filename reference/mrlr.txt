License: CC BY 4.0
arXiv:2406.18560v1 [math.GM] 27 May 2024
A Multi-resolution Low-rank Tensor Decomposition
Abstract
The (efficient and parsimonious) decomposition of higher-order tensors is a fundamental problem with numerous applications in a variety of fields. Several methods have been proposed in the literature to that end, with the Tucker and PARAFAC decompositions being the most prominent ones. Inspired by the latter, in this work we propose a multi-resolution low-rank tensor decomposition to describe (approximate) a tensor in a hierarchical fashion. The central idea of the decomposition is to recast the tensor into multiple lower-dimensional tensors to exploit the structure at different levels of resolution. The method is first explained, an alternating least squares algorithm is discussed, and preliminary simulations illustrating the potential practical relevance are provided.

Index Termsâ€”â€‰ Tensor decomposition, Low-rank approximation, Kronecker decomposition, multi-resolution approximation.

1Introduction
We live in a digital age where common-life devices, from smartphones to cars, generate massive amounts of data that provide researchers and practitioners a range of opportunities. Processing contemporary information comes, however, at a cost, since data sources are messy and heterogeneous. In this context, parsimonious models emerge as an ideal tool to enhance efficiency when processing such vast amounts of information. This can be done by leveraging the structure of the data, as is the case of information living in multiple (possibly many) dimensions. Multi-dimensional data are prevalent in numerous fields, with representative examples including chemometrics, bioengineering, communications, hyper-spectral imaging, or psychometrics [1, 2]. Traditionally, matrices were used to model those datasets, but tensor-representation models have been recently breaking through. Multi-dimensional arrays, or tensors, are data structures that generalize the concept of vectors and matrices to highly-dimensional domains. In recent years, tensors have also been applied to address numerous data science and machine learning tasks, from simple interpolation to supervised classification [3].

In this data-science context, a problem of particular interest is that of tensor decomposition, which tries to estimate a set of latent factors that summarize the tensor. Many tensor decompositions were developed as the generalization of well-known matrix-decomposition methods to high-dimensional domains [4, 5]. This was the case of the PARAFAC tensor decomposition [6] and its generalization, the Tucker tensor decomposition [7], which can be both understood as higher-order generalizations of the SVD decomposition of a matrix. More specifically, these decompositions aim at describing (approximating) the tensor as a sum of rank-1 tensors, decomposing it as a sum of outer products of vectors (called factors). The PARAFAC decomposition is conceptually simple and its representation complexity scales gracefully (the number of parameters grows linearly with the rank). The Tucker decomposition enjoys additional degrees of freedom at the cost of greater complexity (exponential dependence of the number of parameters with respect to the rank). Hierarchical tensor decompositions, such as the Tensor Train (TT) decomposition [8] or a hierarchical Tucker (hTucker) decomposition [9], try to alleviate this problem. The former unwraps the tensor into a chain of three-dimensional tensors, and the latter generalizes the same idea by organizing the dimensions in a binary tree. Furthermore, in recent years significant effort has been devoted to modify existing decomposition algorithms to deal with factor constraints (e.g., non-negativeness), promote certain priors (e.g., factor sparsity), or be robust to imperfections [10] [11] [12].

However, little to no work has been carried out to study the tensor decomposition from a multi-resolution perspective. This can be specially interesting for tensor signals such as videos, where 2-, 3-, and 4-dimensional components are mixed in a single tensor. In this work, we postulate a simple but novel multi-resolution low-rank decomposition method. More specifically, this paper:

â€¢ Introduces a new multi-resolution tensor decomposition to exploit the low-rank structure of a tensor at different resolutions.
â€¢ Proposes an algorithm to implement the decomposition.
â€¢ Tests the benefits of the model via numerical simulations.
Regarding the first contribution, rather than postulating a low-rank decomposition of the tensor using the original multidimensional representation, we 1) consider a collection of lower-order multidimensional representations of the tensor (where several of the original modes of the tensor are combined into a single one); 2) postulate a low-rank decomposition for each of the lower-dimensional representations; 3) map each of the representations back to the original tensor domain; and 4) model the original tensor as the sum of such low-rank representations. As illustrated in detail in the manuscript, this results in an efficient decomposition method capable of combining low-rank structures present at different resolutions.

Section 2 introduces notation and tensor preliminaries. Section 3 presents our decomposition method. A simple algorithmic approach to address the decomposition is described in Section 4. Illustrative numerical experiments are provided in Section 5.

2Notation and tensor preliminaries
The entries of a (column) vector 
ğ±
, a matrix 
ğ—
 and a tensor â€„
ğ—
 â€„ are denoted by 
[
ğ±
]
ğ‘›
, 
[
ğ—
]
ğ‘›
1
,
ğ‘›
2
 and 
[
 
ğ—
 
 
]
ğ‘›
1
,
ğ‘›
2
,
â€¦
,
ğ‘›
ğ¼
, respectively, with 
ğ¼
 denoting the order of tensor â€„
ğ—
 â€„. Moreover, the 
ğ‘›
th column of matrix 
ğ—
 is denoted by 
[
ğ—
]
ğ‘›
. Sets are represented by calligraphic capital letters. The cardinality of a set 
ğ’®
 is denoted by 
|
ğ’®
|
. When a set 
ğ’®
 is ordered, we use the notation 
ğ’®
â¢
(
ğ‘–
)
 with 
1
â‰¤
ğ‘–
â‰¤
|
ğ’®
|
 to denote the 
ğ‘–
th element of the set. The vertical concatenation of the columns of matrix 
ğ—
 is denoted by 
vec
â¢
(
ğ—
)
. 
â€–
ğ—
â€–
ğ¹
 is the Frobenious norm of matrix 
ğ—
, which can be equivalently written as 
â€–
vec
â¢
(
ğ—
)
â€–
2
.

2.1Tensor to matrix unfolding
Given a tensor â€„
ğ—
 â€„ of order 
ğ¼
 and size 
ğ‘
1
Ã—
â€¦
Ã—
ğ‘
ğ¼
, there are many ways to unfold the entries of the tensor into a matrix 
ğ—
. In this section, we are interested in unfoldings where the columns of matrix 
ğ—
 represent one of the original modes of â€„
ğ—
 â€„ and the rows of 
ğ—
 represent all the other modes of the tensor. Mathematically, we define the matrix unfolding operator as

ğ—
=
mat
ğ‘
â¢
(
 
ğ—
 
 
)
âˆˆ
â„
(
ğ‘
1
â¢
â€¦
â¢
ğ‘
ğ‘
âˆ’
1
â¢
ğ‘
ğ‘
+
1
â¢
â€¦
â¢
ğ‘
ğ¼
)
Ã—
ğ‘
ğ‘
â¢
where
(1)
[
ğ—
]
ğ‘˜
,
ğ‘›
ğ‘
=
[
 
ğ—
 
 
]
ğ‘›
1
,
â€¦
,
ğ‘›
ğ¼
â¢
and
ğ‘˜
=
ğ‘›
1
+
âˆ‘
ğ‘–
=
2
,
ğ‘–
â‰ 
ğ‘
ğ¼
(
ğ‘›
ğ‘–
âˆ’
1
)
â¢
âˆ
ğ‘—
=
2
,
ğ‘—
â‰ 
ğ‘
ğ‘–
âˆ’
1
ğ‘
ğ‘—
.
where 
ğ‘
â‰¤
ğ¼
 and, to simplify exposition, we have assumed that 
ğ‘
>
1
.

2.2Tensor to lower-order tensor unfolding
Consider a tensor â€„
ğ—
 â€„, of order 
ğ¼
, and let 
â„
:=
{
1
,
2
,
â€¦
,
ğ¼
}
 denote the set containing the indexes of all the modes of â€„
ğ—
 â€„.

Definition 1
The ordered set 
ğ’«
=
{
ğ’«
1
,
â€¦
,
ğ’«
ğ‘ƒ
}
 is a partition of the set 
â„
 if it holds that: 
ğ’«
ğ‘
â‰ 
âˆ…
 for all 
ğ‘
, 
ğ’«
ğ‘
âˆ©
ğ’«
ğ‘
â€²
=
âˆ…
 for all 
ğ‘
â€²
â‰ 
ğ‘
, and 
â‹ƒ
ğ‘
=
1
ğ‘ƒ
ğ’«
ğ‘
=
â„
.

We are interested in reshaping the entries of the 
ğ¼
th order tensor â€„
ğ—
 â€„ of size 
ğ‘
1
Ã—
â€¦
Ã—
ğ‘
ğ¼
 to generate a lower-order tensor 
 
ğ—
 
 
Ë‡
, with order 
ğ‘ƒ
<
ğ¼
 and according to a given partition 
ğ’«
=
{
ğ’«
1
,
â€¦
,
ğ’«
ğ‘ƒ
}
 as specified next

 
ğ—
 
 
Ë‡
=
ten
ğ’«
â¢
(
 
ğ—
 
 
)
âˆˆ
â„
âˆ
ğ‘—
=
1
|
ğ’«
1
|
|
ğ’«
1
â¢
(
ğ‘—
)
|
Ã—
â€¦
Ã—
âˆ
ğ‘—
=
1
|
ğ’«
ğ‘ƒ
|
|
ğ’«
ğ‘ƒ
â¢
(
ğ‘—
)
|
(2)
[
 
ğ—
 
 
Ë‡
]
ğ‘˜
1
,
â€¦
,
ğ‘˜
|
ğ’«
|
=
[
 
ğ—
 
 
]
ğ‘›
1
,
â€¦
,
ğ‘›
ğ¼
â¢
and
ğ‘˜
ğ‘
=
ğ‘›
ğ’«
ğ‘
â¢
(
1
)
â¢
if
â¢
|
ğ’«
ğ‘
|
=
1
ğ‘˜
ğ‘
=
ğ‘›
ğ’«
ğ‘
â¢
(
1
)
+
âˆ‘
ğ‘–
=
2
|
ğ’«
ğ‘
|
(
ğ‘›
ğ’«
ğ‘
â¢
(
ğ‘–
)
âˆ’
1
)
â¢
âˆ
ğ‘—
=
1
ğ‘–
âˆ’
1
ğ‘
ğ’«
ğ‘
â¢
(
ğ‘—
)
â¢
if
â¢
|
ğ’«
ğ‘
|
>
1
Note that, according to definition of the 
ten
ğ’«
â¢
(
â‹…
)
 operator, the indexes along the 
ğ‘
th mode of 
 
ğ—
 
 
Ë‡
 represent tuples 
(
ğ‘š
ğ’«
ğ‘
â¢
(
1
)
,
â€¦
,
ğ‘š
ğ’«
ğ‘
â¢
(
|
ğ’«
ğ‘
|
)
)
 of indexes of the original tensor â€„
ğ—
 â€„.

Clearly, if 
ğ’«
=
{
â„
}
, so that 
ğ‘ƒ
=
|
ğ’«
|
=
1
 and 
|
ğ’«
1
|
=
ğ¼
, we have that 
ten
ğ’«
â¢
(
 
ğ—
 
 
)
=
vec
â¢
(
 
ğ—
 
 
)
. On the other hand, if 
ğ’«
=
{
{
1
}
,
{
2
}
,
â€¦
,
{
ğ¼
}
}
, so that 
ğ‘ƒ
=
|
ğ’«
|
=
ğ¼
 and 
|
ğ’«
ğ‘
|
=
1
 for all 
ğ‘
, we have that 
ten
ğ’«
â¢
(
 
ğ—
 
 
)
=
 
ğ—
 
 
Ë‡
.

Finally, the inverse operator of (2), which recovers the original tensor â€„
ğ—
 â€„ using as input the reshaped 
 
ğ—
 
 
Ë‡
=
ten
ğ’«
â¢
(
 
ğ—
 
 
)
, is denoted by 
unten
ğ’«
â¢
(
 
ğ—
 
 
Ë‡
)
=
 
ğ—
 
 
. Since the definition of 
unten
ğ’«
â¢
(
â‹…
)
 starting from (2) is straightforward, it is omitted for conciseness.

2.3Low-rank PARAFAC tensor decomposition
Consider the 
ğ¼
th order tensor â€„
ğ—
 â€„ along with the matrices 
ğ…
ğ‘–
âˆˆ
â„
ğ‘
ğ‘–
Ã—
ğ‘…
 for 
ğ‘–
=
1
,
â€¦
,
ğ¼
. Then, â€„
ğ—
 â€„ is said to have rank 
ğ‘…
 if it can be written as

 
ğ—
 
 
=
âˆ‘
ğ‘Ÿ
=
1
ğ‘…
[
ğ…
1
]
ğ‘Ÿ
âŠš
[
ğ…
2
]
ğ‘Ÿ
âŠš
â€¦
âŠš
[
ğ…
ğ¼
]
ğ‘Ÿ
(3)
where 
âŠš
 is the generalization of the outer product for more than two vectors. That is, if 
ğ±
âˆˆ
â„
ğ‘
1
, 
ğ²
âˆˆ
â„
ğ‘
2
, 
ğ³
âˆˆ
â„
ğ‘
3
 are three generic vectors, then 
ğ±
âŠš
ğ²
âŠš
ğ³
 is a tensor of order 
ğ¼
=
3
 satisfying 
[
ğ±
âŠš
ğ²
âŠš
ğ³
]
ğ‘›
1
,
ğ‘›
2
,
ğ‘›
3
=
[
ğ±
]
ğ‘›
1
â¢
[
ğ²
]
ğ‘›
2
â¢
[
ğ³
]
ğ‘›
3
âˆˆ
â„
.

The decomposition in (3) is oftentimes referred to as canonical polyadic decomposition or PARAFAC decomposition, with matrices 
ğ…
ğ‘–
 being referred to as factors. As in the case of matrices, moderate values of 
ğ‘…
 induce a parsimonious description of the tensor, since the 
âˆ
ğ‘–
=
1
ğ¼
ğ‘
ğ‘–
 values in â€„
ğ—
 â€„ can be equivalently represented by the 
âˆ‘
ğ‘–
=
1
ğ¼
ğ‘…
â¢
ğ‘
ğ‘–
 entries in 
{
ğ…
ğ‘–
}
ğ‘–
=
1
ğ¼
.

Using the Khatri-Rao product, denoted as 
âŠ™
, and the different unfolding operators introduced in the previous sections, we have that

mat
ğ‘
â¢
(
 
ğ—
 
 
)
=
âˆ‘
ğ‘Ÿ
=
1
ğ‘…
mat
ğ‘
â¢
(
[
ğ…
1
]
ğ‘Ÿ
âŠš
[
ğ…
2
]
ğ‘Ÿ
âŠš
â€¦
âŠš
[
ğ…
ğ¼
]
ğ‘Ÿ
)
(4)
=
(
ğ…
ğ¼
âŠ™
â€¦
âŠ™
ğ…
ğ‘
+
1
âŠ™
ğ…
ğ‘
âˆ’
1
âŠ™
â€¦
âŠ™
ğ…
1
)
â¢
(
ğ…
ğ‘
)
ğ‘‡
ten
ğ’«
â¢
(
 
ğ—
 
 
)
=
âˆ‘
ğ‘Ÿ
=
1
ğ‘…
ten
ğ’«
â¢
(
[
ğ…
1
]
ğ‘Ÿ
âŠš
[
ğ…
2
]
ğ‘Ÿ
âŠš
â€¦
âŠš
[
ğ…
ğ¼
]
ğ‘Ÿ
)
=
âˆ‘
ğ‘Ÿ
=
1
ğ‘…
(
[
ğ…
Ë‡
1
]
ğ‘Ÿ
âŠš
[
ğ…
Ë‡
2
]
ğ‘Ÿ
âŠš
â€¦
âŠš
[
ğ…
Ë‡
ğ‘ƒ
]
ğ‘Ÿ
)
with
ğ…
Ë‡
ğ‘
=
ğ…
ğ’«
ğ‘
â¢
(
|
ğ’«
ğ‘
|
)
âŠ™
â€¦
âŠ™
ğ…
ğ’«
ğ‘
â¢
(
2
)
âŠ™
ğ…
ğ’«
ğ‘
â¢
(
1
)
.
(5)
These expressions will be leveraged in the next section.

3Multi-resolution low-rank decomposition
Consider a collection of partitions 
ğ’«
(
1
)
,â€¦,
ğ’«
(
ğ¿
)
, with 
|
ğ’«
(
ğ‘™
)
|
â‰¤
|
ğ’«
(
ğ‘™
â€²
)
|
 for 
ğ‘™
<
ğ‘™
â€²
. Given the 
ğ¼
th order tensor â€„
ğ—
 â€„ and the collection of partitions 
ğ’«
(
1
)
,â€¦,
ğ’«
(
ğ¿
)
, we propose the following decomposition for the tensor at hand

â€„
ğ—
 	
=
âˆ‘
ğ‘™
=
1
ğ¿
 
ğ™
 
 
ğ‘™
,
with
â¢
rank
â¢
(
ten
ğ’«
(
ğ‘™
)
â¢
(
 
ğ™
 
 
ğ‘™
)
)
â‰¤
ğ‘…
ğ‘™
,
(6)
which can be equivalently written as

â€„
ğ—
 	
=
âˆ‘
ğ‘™
=
1
ğ¿
unten
ğ’«
(
ğ‘™
)
â¢
(
 
ğ™
 
 
Ë‡
ğ‘™
)
,
with
â¢
rank
â¢
(
 
ğ™
 
 
Ë‡
ğ‘™
)
â‰¤
ğ‘…
ğ‘™
.
(7)
where 
ğ‘…
ğ‘™
 is the rank of the tensor associated to the 
ğ‘™
 partition.

Number of parameters: As already explained, one of the most meaningful implications of low-rank tensor models is the fact that they provide a parsimonious description of the tensor, reducing its implicit number of degrees of freedom. The same is true for the decomposition in (6). To be concrete, the tensor 
 
ğ™
 
 
Ë‡
ğ‘™
=
ten
ğ’«
(
ğ‘™
)
â¢
(
 
ğ™
 
 
ğ‘™
)
 has order 
ğ‘ƒ
(
ğ‘™
)
=
|
ğ’«
(
ğ‘™
)
|
, with the dimension of the 
ğ‘
th mode being 
âˆ
ğ‘—
=
1
|
ğ’«
ğ‘
(
ğ‘™
)
|
|
ğ’«
ğ‘
(
ğ‘™
)
â¢
(
ğ‘—
)
|
. As a result, 
 
ğ™
 
 
Ë‡
ğ‘™
 having rank 
ğ‘…
ğ‘™
 implies that

ğ‘…
ğ‘™
â¢
âˆ‘
ğ‘
=
1
ğ‘ƒ
(
ğ‘™
)
âˆ
ğ‘—
=
1
|
ğ’«
ğ‘
(
ğ‘™
)
|
|
ğ’«
ğ‘
(
ğ‘™
)
â¢
(
ğ‘—
)
|
parameters suffice to fully describe the 
âˆ
ğ‘–
=
1
ğ¼
ğ‘
ğ‘–
 entries in 
 
ğ™
 
 
Ë‡
ğ‘™
. Summing across the different 
ğ¿
 factors implies that

âˆ‘
ğ‘™
=
1
ğ¿
ğ‘…
ğ‘™
â¢
âˆ‘
ğ‘
=
1
ğ‘ƒ
(
ğ‘™
)
âˆ
ğ‘—
=
1
|
ğ’«
ğ‘
(
ğ‘™
)
|
|
ğ’«
ğ‘
(
ğ‘™
)
â¢
(
ğ‘—
)
|
parameters suffice to fully describe the 
âˆ
ğ‘–
=
1
ğ¼
ğ‘
ğ‘–
 entries in â€„
ğ™
 â€„.

4Algorithmic implementation
The decomposition introduced in (6) can be obtained by solving the following minimization problem:

min
 
ğ™
 
 
1
â¢
â€¦
â¢
 
ğ™
 
 
ğ¿
â¡
â€–
 
ğ—
 
 
âˆ’
âˆ‘
ğ‘™
=
1
ğ¿
 
ğ™
 
 
ğ‘™
â€–
ğ¹
(8)
s. t.
â¢
rank
â¢
(
ten
ğ’«
(
ğ‘™
)
â¢
(
 
ğ™
 
 
ğ‘™
)
)
â‰¤
ğ‘…
ğ‘™
.
The approach proposed in this section is to estimate each of the 
ğ¿
 tensors sequentially, so that when optimizing with respect to 
 
ğ™
 
 
ğ‘–
 the remaining tensors 
 
ğ™
 
 
ğ‘™
 with 
ğ‘™
â‰ 
ğ‘–
 are kept fixed. As a result, the minimization problem to be solved in the 
ğ‘–
th step is:

min
 
ğ™
 
 
ğ‘–
â¡
â€–
 
ğ—
 
 
âˆ’
âˆ‘
ğ‘™
â‰ 
ğ‘–
ğ¿
 
ğ™
 
 
ğ‘™
âˆ’
 
ğ™
 
 
ğ‘–
â€–
ğ¹
(9)
s. t.
â¢
rank
â¢
(
ten
ğ’«
(
ğ‘–
)
â¢
(
 
ğ™
 
 
ğ‘–
)
)
â‰¤
ğ‘…
ğ‘–
for 
ğ‘–
=
1
,
â€¦
,
ğ¿
. The constraint in (9) can be handled using a PARAFAC decomposition

 
ğ™
 
 
ğ‘–
=
âˆ‘
ğ‘—
=
1
ğ‘…
ğ‘–
[
ğ‡
1
ğ‘–
]
ğ‘—
âŠš
â€¦
âŠš
[
ğ‡
ğ½
ğ‘–
ğ‘–
]
ğ‘—
,
(10)
so that (9) can be equivalently formulated as:

min
ğ‡
1
ğ‘–
,
â€¦
,
ğ‡
ğ½
ğ‘–
ğ‘–
â¡
â€–
 
ğ—
 
 
âˆ’
âˆ‘
ğ‘™
â‰ 
ğ‘–
ğ¿
 
ğ™
 
 
ğ‘™
âˆ’
âˆ‘
ğ‘—
=
1
ğ‘…
ğ‘–
[
ğ‡
1
ğ‘–
]
ğ‘—
âŠš
â€¦
âŠš
[
ğ‡
ğ½
ğ‘–
ğ‘–
]
ğ‘—
â€–
ğ¹
.
(11)
The above problem is non-convex, but fixing all but one of the factors (say the 
ğ‘—
th one), it becomes linear in 
ğ‡
ğ‘—
ğ‘–
. Under this approach and unfolding the tensor into a matrix 
ğ—
^
ğ‘–
=
mat
ğ‘
â¢
(
 
ğ—
 
 
âˆ’
âˆ‘
ğ‘™
â‰ 
ğ‘–
ğ¿
 
ğ™
 
 
ğ‘™
)
, we have the following update rule to constructing an Alternating Least Squares (ALS) algorithm:

min
ğ‡
ğ‘—
ğ‘–
â¢
â€–
ğ—
^
ğ‘–
âˆ’
(
ğ‡
ğ½
ğ‘–
ğ‘–
âŠ™
â€¦
âŠ™
ğ‡
ğ‘—
+
1
ğ‘–
âŠ™
ğ‡
ğ‘—
âˆ’
1
ğ‘–
âŠ™
â€¦
âŠ™
ğ‡
1
ğ‘–
)
â¢
(
ğ‡
ğ‘—
ğ‘–
)
ğ‘‡
â€–
ğ¹
,
(12)
for all 
ğ‘—
=
1
,
â€¦
,
ğ½
ğ‘–
. Once the 
ğ½
ğ‘–
 factors 
{
ğ‡
ğ‘—
ğ‘–
}
ğ‘—
=
1
ğ½
ğ‘–
 have been obtained, then a) the 
ğ‘–
th tensor 
 
ğ™
 
 
ğ‘–
 is found using (10) and b) the problem in (9) is solved for the next 
ğ‘–
, with 
ğ‘–
=
1
,
â€¦
,
ğ¿
. As a result, 
âˆ‘
ğ‘–
=
1
ğ¿
ğ½
ğ‘–
 instances of (12) need to be run. Note that, when solving (8) via (9)-(12), the order matters. The first 
 
ğ™
 
 
ğ‘™
 to be estimated provides the main (coarser) approximation, while the subsequent ones try to fit the residual error between the main tensor â€„
ğ—
 â€„ and the sum of the previously estimated components 
 
ğ™
 
 
ğ‘™
, providing a finer approximation. Due to the structure 
ğ’«
(
ğ‘™
)
, which carries over 
 
ğ™
 
 
ğ‘™
, the order in which the tensors 
{
 
ğ™
 
 
ğ‘™
}
ğ‘™
=
1
ğ¿
 are approximated is expected to generate variations in the results.

4.1Constructing the partitions
The algorithm in the previous section assumes that the partitions 
ğ’«
(
1
)
,â€¦,
ğ’«
(
ğ¿
)
 are given. A simple generic approach to design 
ğ’«
(
1
)
,â€¦,
ğ’«
(
ğ¿
)
 is to rely on a regular multiresolution construction that splits the index set 
â„
=
{
1
,
2
,
â€¦
,
ğ¼
}
 into smaller sets with the same cardinality. More specifically, one can implement a sequential design with 
ğ¿
=
ğ¼
âˆ’
1
 steps for which, at step 
ğ‘™
âˆˆ
{
1
,
â€¦
,
ğ¿
}
 we split 
â„
 into 
ğ‘™
+
1
 index sets with (approximately) the same number of elements. The collection of 
ğ¿
=
ğ¼
âˆ’
1
 partitions 
ğ’«
(
1
)
,â€¦,
ğ’«
(
ğ¿
)
 is then naturally given by grouping together the sets obtained in each of those steps. To be more clear, let 
âŒŠ
â‹…
âŒ‹
 and 
âŒˆ
â‹…
âŒ‰
 be the floor and ceil operators and consider the collection of partitions 
ğ’«
(
1
)
,â€¦,
ğ’«
(
ğ¿
)
 with 
ğ¿
=
ğ¼
âˆ’
1
 and where the 
ğ‘™
th element is given by

ğ’«
(
ğ‘™
)
=
{
ğ’«
ğ‘›
(
ğ‘™
)
}
ğ‘›
=
1
ğ‘™
+
1
,
with
ğ’«
ğ‘›
(
ğ‘™
)
=
{
âŒˆ
(
ğ‘›
âˆ’
1
)
â¢
ğ¼
/
(
ğ‘™
+
1
)
âŒ‰
,
â€¦
,
âŒŠ
ğ‘›
â¢
ğ¼
/
(
ğ‘™
+
1
)
âŒ‹
}
.
In the above definition we have adopted the convention that, if 
ğ‘¥
 is a whole positive number, 
âŒŠ
ğ‘¥
âŒ‹
=
ğ‘¥
 and 
âŒˆ
ğ‘¥
âŒ‰
=
ğ‘¥
+
1
. Clearly, the partition design in (4.1) is regular in the sense that it achieves 
|
ğ’«
(
ğ‘™
)
|
=
ğ‘™
+
1
 for all 
ğ‘™
 and 
|
ğ’«
(
ğ‘™
)
â¢
(
ğ‘›
)
|
â‰ˆ
ğ¼
/
(
ğ‘™
+
1
)
 for 
ğ‘›
=
1
,
â€¦
,
ğ‘™
+
1
.

To gain insights, suppose for simplicity that our tensor â€„
ğ—
 â€„ of order 
ğ¼
 has size 
ğœ‚
Ã—
â€¦
Ã—
ğœ‚
, i.e., that the value of 
ğ‘
ğ‘–
 is the same across modes, then the number of parameters required to represent â€„
ğ—
 â€„ using the model in (6) and the partitions in (4.1) is approximately

âˆ‘
ğ‘™
=
1
ğ¼
âˆ’
1
ğ‘…
ğ‘™
â¢
(
ğ‘™
+
1
)
â¢
ğœ‚
ğ¼
/
(
ğ‘™
+
ğ‘™
)
,
(14)
which contrasts with the 
âˆ
ğ‘–
=
1
ğ¼
ğ‘
ğ‘–
=
ğœ‚
ğ¼
 entries in â€„
ğ—
 â€„.

Clearly, alternative ways to build the partitions 
ğ’«
(
1
)
,â€¦,
ğ’«
(
ğ¿
)
 are possible. This is especially relevant when prior knowledge exists and one can leverage it to group indexes based on known (di-)similarities among the underlying dimensions. Due to space limitations discussing such alternative partition techniques is out of the scope of this manuscript, but it is part of our ongoing work.

5Numerical experiments
The multi-resolution low-rank (MRLR) tensor decomposition scheme is numerically tested in three different scenarios: the first dealing with an amino acids dataset [13], the second one with a video signal [14], and the third one to approximate a multivariate function. The amino acids dataset is a three-mode tensor of size 
5
Ã—
201
Ã—
61
. The video signal is composed of 173 frames of 
1080
Ã—
720
 pixels each and three channels (R, G, and B). To reduce the computational and memory complexity requirements of the problem, the frames have been sub-sampled and the resolution has been lowered, resulting in a final four-mode tensor of size 
9
Ã—
36
Ã—
54
Ã—
3
. Finally, the multidimensional function in the last scenario has 
â„
3
 as its domain, with each of the three dimensions being discretized using 100 points, so that a tensor with 
10
6
 entries is obtained. The Tensorly Python package is used to benchmark the MRLR tensor decomposition against other tensor decomposition algorithms [15].

The amino acids tensor â€„
ğ—
 â€„ is approximated using a hierarchical structure of a matrix plus a three-mode tensor. The matrix can be build by unfolding the 
5
Ã—
201
Ã—
61
 tensor in different ways. Here, two reshapes have been studied, a 
201
Ã—
305
 unfolding (res-1), and a 
1005
Ã—
61
 unfolding (aka res-2). The structure of the algorithm resembles that of a gradient-boosting-like approach [16]. First, the initial tensor is approximated by a low-rank structure. Then, the residual is approximated by a low-rank structure too. Subsequent residuals are also approximated if necessary. This sequential process can be started from the coarser unfolding, the matrix, or the other way around (reverse). In this experiment, both alternatives have been tested. The rank of the matrix unfolding is fixed while the rank of the three-mode tensor is gradually increased.

Refer to caption
Fig. 1:Normalized Squared Frobenius Error (15) between the original 
5
Ã—
201
Ã—
61
 amino acids tensor and its approximation obtained via the MRLR and the PARAFAC tensor decompositions when the number of parameters (tensor rank) is increased.
The performance of the algorithms has been measured in terms of Normalized Frobenius Error (
NFE
) between the true tensor â€„
ğ—
 â€„ and the approximation 
 
ğ—
 
 
Ë‡
, which is given by

NFE
=
â€–
 
ğ—
 
 
âˆ’
 
ğ—
 
 
Ë‡
â€–
ğ¹
/
â€–
 
ğ—
 
 
â€–
ğ¹
.
(15)
The results are reported in Fig. 1. The MRLR decomposition is compared to the PARAFAC decomposition. The res-1 unfolding of the matrix (square-like unfolding) seems to perform better than the res-2 unfolding (tall unfolding). Then, the approximation from the coarser to the finer arrangement beats the reverse one. Moreover, all the MRLR schemes outperform the PARAFAC one in terms of 
NFE
 for the same number of parameters. Indeed, the best-performing MRLR algorithm obtains roughly the same 
NFE
 as the PARAFAC decomposition using 
10
,
000
 parameters less approximately.

In the second test case, the four-mode video tensor â€„
ğ—
 â€„ is unfolded into a 
324
Ã—
162
 matrix and a 
9
Ã—
36
Ã—
162
 three-mode tensor. The ranks of the matrix and the three-mode tensors have been fixed to 1. The rank of the four-mode tensor approximation is gradually increased. The results are provided in Fig. 2. Again, the coarser-to-finer arrangement outperforms both, the reverse (finer-to-coarser) arrangement, and the PARAFAC decomposition. It needs approximately 
1
,
500
 parameters less to achieve the same 
NFE
.

Refer to caption
Fig. 2:Normalized Squared Frobenius Error (15) between the original 
9
Ã—
36
Ã—
54
Ã—
3
 video signal tensor and its approximation obtained via the MRLR and the PARAFAC tensor decompositions when the number of parameters (tensor rank) is increased.
Finally, we tested the MRLR tensor decomposition in a third test case to approximate a multivariate function. Given a set of 
ğ¼
 input variables, with 
ğ‘¥
ğ‘–
 denoting the 
ğ‘–
th input variable and 
ğ’³
ğ‘–
 the set of all possible values of 
ğ‘¥
ğ‘–
, we are interested in functions that map any element 
(
ğ‘¥
1
,
â€¦
,
ğ‘¥
ğ¼
)
âˆˆ
ğ’³
 into a real value. When these functions are discrete, tensors can be used to model them efficiently. Continuous functions can be discretized/quantized. Tensor decomposition methods can then be leveraged for applications such as approximation, or denoising [17]. In such a context, we tested the MRLR tensor decomposition algorithm to model the following multivariate continuous function 
ğ‘“
:
â„
3
â†¦
â„
:

ğ‘“
â¢
(
ğ‘¥
1
,
ğ‘¥
2
,
ğ‘¥
3
)
=
ğ‘¥
1
2
+
ğ‘¥
2
2
ğ‘’
|
ğ‘¥
2
+
ğ‘¥
3
|
.
(16)
Sampling a three dimensional grid of discrete values ranging from 
âˆ’
5
 to 
5
 with an step-size of 
0.1
 leads to a 
100
Ã—
100
Ã—
100
 tensor â€„
ğ—
 â€„ that summarizes the multivariate function in (16). The tensor â€„
ğ—
 â€„ can be approximated using the MRLR tensor decomposition to leverage parsimony. The tensor â€„
ğ—
 â€„ is unfolded into a 
10000
Ã—
100
 matrix, and the coarser-to-finer setup has been implemented. The performance of the MRLR tensor decomposition is again compared to that of the PARAFAC decomposition in terms of 
NFE
 for an increasing number of parameters. The results are shown in Fig. 3. As in previous scenarios, the MRLR decomposition outperforms the PARAFAC decomposition for the same number of parameters consistently. At some points, the difference between both algorithms is particularly high. For example, the MRLR tensor decomposition needs roughly 
15
,
000
 parameters to achieve 
1
%
 of 
NFE
, while the PARAFAC decomposition needs more than 
30
,
000
 parameters.

Refer to caption
Fig. 3:Normalized Squared Frobenius Error (15) between the 
100
Ã—
100
Ã—
100
 tensor sampled from the multivariate function in (16) and its approximation obtained via the MRLR and the PARAFAC tensor decompositions when the number of parameters (tensor rank) is increased.
6Conclusions
This paper presented a parsimonious multi-resolution low-rank (MRLR) tensor decomposition to approximate a tensor as a sum of low-order tensor unfoldings. An Alternating Least Squares (ALS) algorithm was proposed to implement the MRLR tensor decomposition. Then, the MRLR tensor decomposition was compared against the PARAFAC decomposition in two real-case scenarios, and also in a multivariate function approximation problem. The MRLR tensor decomposition outperformed the PARAFAC decomposition for the same number of parameters, showing that it can efficiently leverage information defined at different dimensional orders.

References
[1]
R. Bro, â€œParafac. tutorial and applications,â€ Chemometrics and Intelligent Laboratory Systems, vol. 38, no. 2, pp. 149â€“171, 1997.
[2]
R. B. Cattell, â€œParallel proportional profiles and other principles for determining the choice of factors by rotation,â€ Psychometrika, vol. 9, no. 4, pp. 267â€“283, 1944.
[3]
E. E. Papalexakis, C. Faloutsos, and N. D. Sidiropoulos, â€œTensors for data mining and data fusion: Models, applications, and scalable algorithms,â€ ACM Transactions on Intelligent Systems and Technology (TIST), vol. 8, no. 2, pp. 1â€“44, 2016.
[4]
T. G. Kolda and B. W. Bader, â€œTensor decompositions and applications,â€ SIAM Review, vol. 51, no. 3, pp. 455â€“500, 2009.
[5]
N. D. Sidiropoulos, L. De Lathauwer, X. Fu, K. Huang, E. E. Papalexakis, and C. Faloutsos, â€œTensor decomposition for signal processing and machine learning,â€ IEEE Transactions on Signal Processing, vol. 65, no. 13, pp. 3551â€“3582, 2017.
[6]
R. A. Harshman, â€œFoundations of the parafac procedure: Models and conditions for an â€œexplanatoryâ€ multimodal factor analysis,â€ UCLA Working Papers Phonetics, vol. 16, pp. 1â€“84, 1970.
[7]
L. R. Tucker, â€œSome mathematical notes on three-mode factor analysis,â€ Psychometrika, vol. 31, no. 3, pp. 279â€“311, 1966.
[8]
I. V. Oseledets, â€œTensor-train decomposition,â€ SIAM Journal on Scientific Computing, vol. 33, no. 5, pp. 2295â€“2317, 2011.
[9]
L. Grasedyck, D. Kressner, and C. Tobler, â€œA literature survey of low-rank tensor approximation techniques,â€ GAMM-Mitteilungen, vol. 36, no. 1, pp. 53â€“78, 2013.
[10]
D. Wang, F. Cong, and T. Ristaniemi, â€œHigher-order nonnegative candecomp/parafac tensor decomposition using proximal algorithm,â€ in IEEE International Conference on Acoustics, Speech and Signal Processing (ICASSP).   IEEE, 2019, pp. 3457â€“3461.
[11]
Q. Xie, Q. Zhao, D. Meng, and Z. Xu, â€œKronecker-basis-representation based tensor sparsity and its applications to tensor recovery,â€ IEEE Transactions on Pattern Analysis and Machine Intelligence, vol. 40, no. 8, pp. 1888â€“1902, 2017.
[12]
O. Kaya and B. UÃ§ar, â€œParallel candecomp/parafac decomposition of sparse tensors using dimension trees,â€ SIAM Journal on Scientific Computing, vol. 40, no. 1, pp. C99â€“C130, 2018.
[13]
R. Bro, â€œMulti-way analysis in the food industry-models, algorithms, and applications,â€ Ph.D. dissertation, University of Amsterdam (NL), 1998.
[14]
S. Rozada, â€œMulti-resolution low-rank tensor decomposition,â€ https://github.com/sergiorozada12/multiresolution-tensor-decomposition, 2021.
[15]
J. Kossaifi, Y. Panagakis, A. Anandkumar, and M. Pantic, â€œTensorly: Tensor learning in python,â€ arXiv preprint arXiv:1610.09555, 2016.
[16]
J. H. Friedman, â€œGreedy function approximation: a gradient boosting machine,â€ Annals of Statistics, pp. 1189â€“1232, 2001.
[17]
N. Kargas and N. D. Sidiropoulos, â€œSupervised learning and canonical decomposition of multivariate functions,â€ IEEE Transactions on Signal Processing, vol. 69, pp. 1097â€“1107, 2021.